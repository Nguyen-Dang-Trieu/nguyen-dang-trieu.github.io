---
title: Linux IO
date: 2025-1-21
categories: [Linux]
tags: [Device Driver, IO]
author: Trieu
image:
  path: assets/articles/2025/Linux_IO/2025-1-27-header.png
  alt: Linux IO
---

## Mở đầu
Đối với một ứng dụng (hay một tiến trình trong hệ điều hành), không gian bộ nhớ được chia thành 2 phần:
- Không gian hạt nhân **(Kernel-space)**: được chia sẽ với các tiến trình khác.
- Không gian người dùng **(User-space)**: riêng đối với mỗi tiến trình.

Cả hai đều nằm trong không gian địa chỉ ảo **(Virtual Memory)**. Tiến trình người dùng không thể trực tiếp truy cập vào không gian kernel. Thay vào đó, nó chỉ có quyền truy cập vào 
không gian người dùng **(User-space)** và cần sao chép dữ liệu vào không gian kernel thông qua cơ chế do hệ điều hành cung cấp (như các lời gọi hệ thống - **System call**). Sau đó, kernel 
sẽ xử lý dữ liệu theo yêu cầu của tiến trình.

## IO là gì

Trong hệ thống máy tính, **I/O (Input/Output)** có nghĩa là đầu vào và đầu ra. Tùy theo đối tượng hoạt động, I/O có thể được phân loại thành nhiều mô hình khác nhau như: I/O đĩa, I/O mạng, 
I/O ánh xạ bộ nhớ, I/O trực tiếp, I/O cơ sở dữ liệu, v.v. Bất kỳ hệ thống nào có các kiểu đầu vào và đầu ra đều có thể được coi là một **hệ thống I/O**. Có thể nói, I/O chính là kênh trao 
đổi dữ liệu và cầu nối tương tác giữa con người 🙍‍♂️ và máy tính 💻 trong toàn bộ hệ điều hành. Đây là một khái niệm phổ quát, không phụ thuộc vào ngôn ngữ lập trình hay công nghệ phát 
triển cụ thể.

Trong các hệ thống ngày nay, I/O đóng vai trò quan trọng hàng đầu. Các hệ thống hiện đại thường phải xử lý khối lượng lớn tệp tin và các hoạt động cơ sở dữ liệu phức tạp. Những hoạt 
động này phụ thuộc nhiều vào hiệu suất I/O của hệ thống, và đây thường là nguyên nhân chính gây ra tắc nghẽn hiệu năng. Nếu hiệu suất I/O không đủ cao, toàn bộ hệ thống sẽ bị chậm lại, 
bất kể CPU hay bộ nhớ có mạnh đến đâu.

Để cải thiện hiệu suất I/O, các giải pháp tối ưu hóa đã được áp dụng, chẳng hạn như:
- Bổ sung bộ nhớ đệm trong kiến trúc hệ thống nhằm giảm độ trễ và tăng tốc độ phản hồi.
- Thay thế ổ cứng cơ học (HDD) truyền thống bằng ổ đĩa thể rắn (SSD) để tăng tốc độ truy cập dữ liệu ở cấp độ phần cứng.
  
Có thể nói, phần lớn không gian tối ưu hóa hệ thống nằm ở việc cải thiện liên kết I/O, bởi vì đây thường là **điểm nghẽn chính**. Trong khi đó, hiệu suất của CPU và bộ nhớ hiếm khi là nguyên nhân gây ra tắc nghẽn trong hệ thống hiện đại.

**Vậy dữ liệu vào ở đâu và ra ở đâu?**
- Input: Dữ liệu được nhập vào bộ nhớ (RAM).
- Output: Dữ liệu được xuất ra các thiết bị I/O (như ổ đĩa, mạng, hoặc các thiết bị cần tương tác với bộ nhớ).

![CPU -> Ram -> Disk](/assets/articles/2025/Linux_IO/2025-1-27-IO.png){: .normal }
_Flow IO_

Một vùng của bộ nhớ chính (thường là DRAM) được dùng để lưu trữ tạm thời nội dung của hệ thống tệp (file system), bao gồm cả dữ liệu và siêu dữ liệu.

## Giao tiếp IO (Input/Output)
Giao tiếp IO là quá trình truyền dữ liệu trực tiếp giữa các thiết bị ngoại vi (thiết bị IO) và bộ nhớ thông qua các giao diện IO. Hệ điều hành cung cấp các giao diện IO (được đóng gói sẵn) mà chúng ta có thể sử dụng trực tiếp trong quá trình lập trình.

![API Interface IO](/assets/articles/2025/Linux_IO/2025-1-28-InterfaceIO.png){: .normal }

Đối với người dùng, khi muốn giao tiếp với các thiết bị ngoại vi, chỉ cần sử dụng các lệnh gọi hệ thống (System Call) được hệ điều hành hỗ trợ, mà không cần phải quan tâm đến cách thức hoạt động bên trong.

## Bộ nhớ đệm ở khắp mọi nơi
![Buffer IO](/assets/articles/2025/Linux_IO/2025-1-28-buffer.png){: .normal }

Khi chương trình thực hiện các thao tác trên tệp, dữ liệu người dùng (User Data) được chuyển đến đĩa (Disk) theo các cấp bậc từ trên xuống dưới, như trong hình minh họa. Hệ thống được chia thành chế độ người dùng **(User Mode)** và chế độ nhân **(Kernel Mode)**, được phân cách bởi đường liền màu đen ở giữa.

### 1.Thao tác tệp ở User Mode
- Thư viện stdio (C Library): Các hàm thao tác tệp như `fread`, `fwrite` được cung cấp bởi thư viện C (stdio). Những hàm này được đóng gói để hỗ trợ đa nền tảng và hoạt động trong User Mode.
- Bộ đệm stdio (Stdio Buffer):
  - Các hàm `stdio` sử dụng bộ đệm riêng (stdio buffer) trong chế độ người dùng để giảm tần suất gọi lệnh gọi hệ thống (System Call), vốn rất tốn kém.
Ví dụ: Khi bạn ghi hoặc đọc tệp với kích thước nhỏ, thư viện stdio sẽ gom dữ liệu vào bộ đệm trước, sau đó mới gọi một lần ghi/đọc lớn hơn để cải thiện hiệu suất.
  - Người dùng có thể tùy chỉnh bộ đệm này bằng các hàm như `setbuf()` hoặc xóa bộ đệm bằng cách gọi `fflush()`.

### 2.Thao tác tệp ở Kernel Mode
- Kernel Buffer Cache: Khi Kernel Mode, giữa các lệnh gọi hệ thống (read, write) và thao tác thực tế trên đĩa, có một lớp bộ đệm gọi là **Kernel Buffer Cache**.
- Trong Linux, lớp này gồm hai khái niệm:
  - **Page Cache**: Lưu trữ nội dung của các tệp, liên quan chặt chẽ đến hệ thống tệp (file system).
  - **Buffer Cache**: Lưu trữ dữ liệu của các khối thiết bị lưu trữ (như sector của đĩa), không phụ thuộc vào hệ thống tệp.
Hai khái niệm này đôi khi dễ bị nhầm lẫn, nhưng Page Cache thường được dùng cho tệp, còn Buffer Cache dùng cho dữ liệu thiết bị lưu trữ cấp thấp.

## Ngăn xếp IO của Linux
Mặc dù chúng ta có thể đơn giản đọc/ghi dữ liệu từ các thiết bị ngoại vi thông qua các lệnh gọi hệ thống (System Call), nhưng lợi ích thực sự đến từ kiến trúc ngăn xếp IO hoàn chỉnh của Linux.

![Linux IO Stack](/assets/articles/2025/Linux_IO/2025-1-28-StackLinuxIO_v6.9.png){: .normal }

Trong Linux, ngăn xếp IO được chia thành ba cấp độ chính:

**Lớp hệ thống tệp (File System Layer)**
- Tại lớp này, các lệnh gọi hệ thống như write(2) sẽ sao chép dữ liệu từ không gian người dùng (User Space) sang Bộ nhớ đệm của hệ thống tệp (File System Buffer) trong không gian kernel.
- Bộ đệm này giúp tăng hiệu suất bằng cách gom các thao tác nhỏ lẻ thành một khối lớn hơn trước khi đồng bộ với lớp bên dưới.
  
**Lớp khối (Block Layer)**
- Lớp khối (Block Layer) quản lý hàng đợi I/O (IO Queue) của các thiết bị lưu trữ khối (Block Storage Devices). Nhiệm vụ chính của lớp này là hợp nhất và sắp xếp các yêu cầu I/O theo thứ tự tối ưu, nhằm cải thiện hiệu suất truy cập các thiết bị lưu trữ
  
**Lớp thiết bị (Device Layer)**
- Đây là lớp trực tiếp tương tác với phần cứng, sử dụng **DMA (Direct Memory Access)** để truyền dữ liệu giữa bộ nhớ và thiết bị lưu trữ cụ thể mà không cần CPU can thiệp nhiều.

### Các cơ chế được kết nối với ngăn xếp IO của Linux như thế nào?
Hình trên hơi phức tạp. Hãy vẽ một sơ đồ đơn giản và thêm vị trí của các cơ chế này

![Simple Linux IO Stack](/assets/articles/2025/Linux_IO/2025-1-28-Simple_LinuxIO.png){: .normal }

### Quá trình đọc dữ liệu trong Buffered I/O truyền thống với hàm `read(2)?
Ngăn xếp IO trong Linux liên kết chặt chẽ với các cơ chế hoạt động từ việc mở tệp (open) đến đọc tệp (read). Dưới đây là quy trình đơn giản hóa của Buffered IO trong trường hợp đọc một tệp không tồn tại trong Cache:

**Mở tệp open(2)**

Khi thực hiện lệnh open(2) để mở tệp, kernel sẽ thiết lập các cấu trúc dữ liệu liên quan, như mô tả thông tin về tệp trong hệ thống.

**Đọc tệp read(2)**

Lệnh read(2) được gọi để yêu cầu đọc dữ liệu từ tệp. Quá trình này diễn ra qua các bước sau:
- Lớp hệ thống tệp (File System layer): Kernel kiểm tra Page Cache của hệ thống tệp. Nếu dữ liệu cần đọc không tồn tại trong Page Cache, kernel sẽ ánh xạ vị trí trên đĩa cần đọc.
- Lớp khối (Block Layer):
  - Yêu cầu đọc dữ liệu được gửi đến hàng đợi IO của thiết bị khối (IO Queue).
  - Tại đây, hệ thống quản lý và sắp xếp các yêu cầu IO để tối ưu hóa hiệu suất truy cập đĩa.
- Lớp trình điều khiển thiết bị (Device Driver layer):
  - Sau khi yêu cầu được xử lý tại hàng đợi, kernel chuyển nó đến trình điều khiển thiết bị (Device Driver).
  - Trình điều khiển sử dụng DMA để đọc các cung đĩa tương ứng vào Bộ nhớ đệm của kernel (Kernel Buffer).

**Trả dữ liệu về không gian người dùng**

Khi dữ liệu đã được đọc từ đĩa vào bộ đệm kernel: Kernel sẽ sao chép dữ liệu từ Bộ nhớ đệm kernel (Kernel Buffer) sang Bộ đệm của người dùng (User Buffer) được chỉ định trong lệnh read(2).

## Blocking/non-blocking and synchronous/asynchronous
*"If routine A calls routine B then routine A is the caller and routine B is the callee. i.e. the caller is the routine which is calling the callee."*

### Blocking/non-blocking
Đối tượng hướng đến ở đây là `caller`.
- **Blocking:** Điều đó có nghĩa là sau khi gọi một hàm, **caller** sẽ đợi giá trị trả về của hàm và luồng **(thread)** ở trạng thái treo.
- **Non-blocking:** Điều đó có nghĩa là sau khi gọi một hàm, **caller** không đợi giá trị trả về của hàm và luồng **(thread)** tiếp tục chạy các chương trình khác (thực hiện các thao tác khác hoặc tiếp tục duyệt xem hàm có trả về giá trị hay không)

### Synchronous/Asynchronous
Đối tượng hướng đến là `callee`.
***Synchronous** execution means the first task in a program must finish processing before moving on to executing the next task whereas **asynchronous** execution means a second task can begin executing in parallel, without waiting for an earlier task to finish.*

Hình ảnh
## Reference
- https://everything2.com/title/caller+vs+callee
- https://www.koyeb.com/blog/introduction-to-synchronous-and-asynchronous-processing#executing-tasks-sync-versus-async
